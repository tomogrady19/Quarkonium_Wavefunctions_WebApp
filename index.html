<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Heavy Meson Radial Wavefunctions</title>
    <!-- PyScript -->
    <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
    <script defer src="https://pyscript.net/latest/pyscript.js"></script>

    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 1.5rem;
        }
        h1, h2 {
            margin-bottom: 0.5rem;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 0.75rem 1.5rem;
            margin-bottom: 1rem;
            align-items: end;
        }
        label {
            font-size: 0.9rem;
            font-weight: 600;
            display: block;
            margin-bottom: 0.2rem;
        }
        input, select, button {
            width: 100%;
            padding: 0.25rem 0.4rem;
            font-size: 0.9rem;
        }
        button {
            cursor: pointer;
        }
        #plot {
            margin-top: 1rem;
            border: 1px solid #ddd;
            padding: 0.75rem;
            min-height: 320px;
        }
        small {
            color: #555;
        }
    </style>

    <py-config>
    {
        "packages": ["numpy", "matplotlib"]
    }
    </py-config>
</head>
<body>
    <h1>Heavy Meson Radial Wavefunctions</h1>
    <p>
        Explore numerically solved radial wavefunctions for heavy quark–antiquark systems
        (charmonium, bottomonium and B<sub>c</sub>), using a non-relativistic Schrödinger
        equation with a phenomenological potential.
    </p>

    <h2>Controls</h2>
    <div class="controls">
        <div>
            <label for="meson-select">Meson type</label>
            <select id="meson-select">
                <option value="charm,charm">Charmonium (c-c)</option>
                <option value="bottom,bottom">Bottomonium (b-b)</option>
                <option value="bottom,charm">B<sub>c</sub> (b-c)</option>
            </select>
        </div>

        <div>
            <label for="n-input">Principal quantum number n</label>
            <input id="n-input" type="number" min="1" step="1" value="1" />
        </div>

        <div>
            <label for="l-input">Angular momentum quantum number l</label>
            <input id="l-input" type="number" min="0" step="1" value="0" />
        </div>

        <div>
            <label for="emin-input">Energy search range (GeV): E<sub>min</sub></label>
            <input id="emin-input" type="number" step="0.01" value="0.3" />
        </div>

        <div>
            <label for="emax-input">Energy search range (GeV): E<sub>max</sub></label>
            <input id="emax-input" type="number" step="0.01" value="0.4" />
        </div>

        <div>
            <button id="plot-btn" py-click="plot_wavefunction()">Plot wavefunction</button>
        </div>
    </div>

    <small>
        Tip: different mesons and (n, l) combinations may require different energy
        ranges to find a bound-state solution.
    </small>

    <div id="plot">
        <!-- Matplotlib figure will be rendered here -->
    </div>

    <py-script>
import numpy as np
import matplotlib.pyplot as plt
from pyscript import display, Element


# ---------- Meson class (SciPy-free version) ----------

def rk4(deriv, y0, x):
    """
    Simple RK4 ODE solver for systems of first-order ODEs.
    deriv: function(y, x) → dy/dx
    y0: initial conditions (array-like)
    x: array of r-values
    """
    y = np.zeros((len(x), len(y0)))
    y[0] = y0

    for i in range(1, len(x)):
        h = x[i] - x[i - 1]
        xi = x[i - 1]
        yi = y[i - 1]

        k1 = deriv(yi, xi)
        k2 = deriv(yi + 0.5 * h * k1, xi + 0.5 * h)
        k3 = deriv(yi + 0.5 * h * k2, xi + 0.5 * h)
        k4 = deriv(yi + h * k3, xi + h)

        y[i] = yi + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)

    return y


def turns(X):
    """Calculate the number of turning points."""
    N = 0
    for i in range(1, len(X) - 1):
        if ((X[i - 1] < X[i] and X[i + 1] < X[i]) or  # local max
            (X[i - 1] > X[i] and X[i + 1] > X[i])):   # local min
            N += 1
    return N


def nodes(X):
    """Calculate the number of nodes (zero crossings)."""
    M = 0
    for i in range(len(X) - 1):
        if X[i] * X[i + 1] <= 0:
            M += 1
    return M


class Meson:
    """Non-relativistic heavy meson model in a phenomenological potential."""

    mass_dict = {'charm': 1.34, 'bottom': 4.7}  # quark masses (GeV)
    u0 = np.array([0.0, 1.0])  # initial condition [u, du/dr]
    ac = 0.0  # convergence threshold for bisection

    def __init__(self, quark1='charm', quark2='charm'):
        if quark1 == quark2 == 'charm':
            state_mass = 3.068  # experimental (n, l) = (1, 0) (GeV)
            self.a = 0.4
            self.rs = np.arange(0.0001, 15.0, 0.01)  # range (1/GeV)
        elif quark1 == quark2 == 'bottom':
            state_mass = 9.3987
            self.a = 0.28
            self.rs = np.arange(0.0001, 9.0, 0.01)
        elif all(q in ['charm', 'bottom'] for q in [quark1, quark2]):
            state_mass = 6.276
            self.a = 0.34
            self.rs = np.arange(0.0001, 15.0, 0.01)
        else:
            raise ValueError("Quarks must be 'charm' or 'bottom'.")

        self.m1 = self.mass_dict[quark1]
        self.m2 = self.mass_dict[quark2]
        self.mu = 1.0 / (1.0 / self.m1 + 1.0 / self.m2)  # reduced mass (GeV)
        self.E = state_mass - self.m1 - self.m2  # state energy (GeV)

        self.n = 1
        self.l = 0
        self.b = 0.2  # default string tension (GeV^2)

    def radial_equation(self, uvec, r):
        """Second-order radial ODE rewritten as a first-order system."""
        u, du_dr = uvec
        if r > 0.0:
            term = (self.l * (self.l + 1) / r**2
                    - 2.0 * self.mu * (self.E - self.b * r + 4.0 * self.a / (3.0 * r)))
            d2u_dr2 = term * u
        else:
            d2u_dr2 = 0.0
        return np.array([du_dr, d2u_dr2])

    def wf_b(self, b):
        """Solve for the radial wavefunction for a given string tension b."""
        self.b = b
        sol = rk4(self.radial_equation, self.u0, self.rs)
        return sol[:, 0]

    def wf_E(self, E):
        """Solve for the radial wavefunction for a given energy E."""
        self.E = E
        sol = rk4(self.radial_equation, self.u0, self.rs)
        return sol[:, 0]

    def TN_b(self, b):
        x_values = self.wf_b(b)
        return [turns(x_values), nodes(x_values)]

    def TN_E(self, E):
        x_values = self.wf_E(E)
        return [turns(x_values), nodes(x_values)]

    def solve_beta(self, A, C):
        """Find b giving a normalisable wavefunction via node/turn matching."""
        B = 0.5 * (A + C)
        A_tn = self.TN_b(A)
        B_tn = self.TN_b(B)
        C_tn = self.TN_b(C)

        while A_tn != B_tn or B_tn != C_tn:
            if abs(B - A) <= self.ac or abs(C - B) <= self.ac:
                break
            if A_tn != B_tn:
                C = B
                C_tn = B_tn
            elif C_tn != B_tn:
                A = B
                A_tn = B_tn
            B = 0.5 * (A + C)
            B_tn = self.TN_b(B)
        self.b = B

    def solve_energy(self, A, C):
        """Find E giving a normalisable wavefunction via node/turn matching."""
        B = 0.5 * (A + C)
        A_tn = self.TN_E(A)
        B_tn = self.TN_E(B)
        C_tn = self.TN_E(C)

        while A_tn != B_tn or B_tn != C_tn:
            if abs(B - A) <= self.ac or abs(C - B) <= self.ac:
                break
            if A_tn != B_tn:
                C = B
                C_tn = B_tn
            elif C_tn != B_tn:
                A = B
                A_tn = B_tn
            B = 0.5 * (A + C)
            B_tn = self.TN_E(B)
        return B

    def solve(self, E_range, n, l):
        """Solve for the normalised radial wavefunction for given (n, l)."""
        self.n = n
        self.l = l

        E = self.solve_energy(*E_range)
        ys = self.wf_E(E)
        prob_density = ys**2

        # normalise
        norm = np.sqrt(np.trapz(prob_density, self.rs))
        if norm > 0:
            ys /= norm
        return ys, E


# ---------- Plotting logic for the web UI ----------

def plot_wavefunction(event=None):
    # Read inputs from the DOM
    meson_value = Element("meson-select").value  # "charm,charm", etc.
    quark1, quark2 = meson_value.split(",")

    n = int(Element("n-input").value)
    l = int(Element("l-input").value)

    Emin = float(Element("emin-input").value)
    Emax = float(Element("emax-input").value)

    # Instantiate meson and (optionally) tune beta for ground state
    meson = Meson(quark1, quark2)
    # Optional: give a quick beta solve for approximate string tension
    # These ranges are rough but reasonable starting points
    if quark1 == "charm" and quark2 == "charm":
        meson.solve_beta(0.15, 0.25)
        system_name = "Charmonium"
    elif quark1 == "bottom" and quark2 == "bottom":
        meson.solve_beta(0.15, 0.35)
        system_name = "Bottomonium"
    else:
        meson.solve_beta(0.1, 0.25)
        system_name = "B\u2095 (bottom–charm)"

    # Solve for the chosen (n, l) and energy range
    ys, E = meson.solve([Emin, Emax], n, l)

    rs = meson.rs

    # Create the plot
    fig, ax = plt.subplots(figsize=(6, 4))
    ax.plot(rs, ys, label=f"n={n}, l={l}")
    ax.set_xlabel(r"$r$  /  GeV$^{-1}$")
    ax.set_ylabel(r"$u_{nl}(r)$")
    ax.set_title(f"{system_name} radial wavefunction (E ≈ {E:.3f} GeV)")
    ax.grid(True)
    ax.legend()

    # Render into the <div id="plot">
    display(fig, target="plot", append=False)
    plt.close(fig)
    </py-script>
</body>
</html>
